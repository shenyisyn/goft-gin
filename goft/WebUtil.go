package goft

import (
	"bytes"
	"fmt"
	"github.com/gin-gonic/gin"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// 读取配置文件
func LoadConfigFile() []byte {
	//dir, _ := os.Executable()
	dir, _ := os.Getwd()
	file := dir + "/application.yaml"
	b, err := ioutil.ReadFile(file)
	if err != nil {
		//	log.Println(err)
		return nil
	}
	return b
}

// 根据 函数生成 funcMap   ast 语法树
func GenTplFunc(path string) {
	path = strings.Replace(path, "\\", "/", -1)
	pList := strings.Split(path, "/")
	pkgName := pList[len(pList)-1]
	dir, err := ioutil.ReadDir(path)
	if err != nil {
		log.Fatal(err)
	}
	funcMap := make(map[string]string)
	impList := make(map[string]struct{})
	for _, f := range dir {
		fp := path + "/" + f.Name()
		if f.IsDir() || filepath.Ext(fp) != ".go" || f.Name() == "funcmap.go" {
			continue
		} else {
			fset := token.NewFileSet()
			ast_file, err := parser.ParseFile(fset, fp, nil, 0|parser.ParseComments)
			if err != nil {
				log.Fatal(err)
			}
			for _, imp := range ast_file.Imports {
				impName := ""
				if imp.Name != nil {
					impName = imp.Name.Name
				}
				impList[fmt.Sprintf("%s %s", impName, imp.Path.Value)] = struct{}{}
			}
			for _, dec := range ast_file.Decls {
				if fn, ok := dec.(*ast.FuncDecl); ok {
					var output []byte
					buffer := bytes.NewBuffer(output)
					newf := &ast.FuncDecl{
						Doc:  fn.Doc,
						Name: &ast.Ident{Name: ""},
						Body: fn.Body,
						Recv: fn.Recv,
						Type: fn.Type,
					}
					format.Node(buffer, fset, newf)
					funcMap[fn.Name.String()] = buffer.String()
				}
			}

		}

	}
	tpl := `
// Code generated by jtthink DO NOT EDIT
package {{.pkg}}
import (
 {{range $k, $v := .import }}
    {{$k}}
 {{end}}
 )
var FuncMap=map[string]interface{}{
 {{range $key, $value := .map }}
   "{{$key}}" :{{$value}},
  {{end}}
}
			`

	buf := bytes.Buffer{}
	tmpl, _ := template.New("funcMap").Parse(tpl)
	_ = tmpl.Execute(&buf, gin.H{"map": funcMap, "pkg": pkgName, "import": impList})
	autocode_file := path + "/funcmap.go"
	autocode, err := os.OpenFile(autocode_file, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0666)
	if err != nil {
		log.Fatal(err)
	}
	log.Println(fmt.Fprint(autocode, buf.String()))
}

// 判断是否数字
func IsNumeric(val interface{}) bool {
	switch val.(type) {
	case int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:
	case float32, float64, complex64, complex128:
		return true
	case string:
		str := val.(string)
		if str == "" {
			return false
		}
		// Trim any whitespace
		str = strings.Trim(str, " \\t\\n\\r\\v\\f")
		if str[0] == '-' || str[0] == '+' {
			if len(str) == 1 {
				return false
			}
			str = str[1:]
		}
		// hex
		if len(str) > 2 && str[0] == '0' && (str[1] == 'x' || str[1] == 'X') {
			for _, h := range str[2:] {
				if !((h >= '0' && h <= '9') || (h >= 'a' && h <= 'f') || (h >= 'A' && h <= 'F')) {
					return false
				}
			}
			return true
		}
		// 0-9,Point,Scientific
		p, s, l := 0, 0, len(str)
		for i, v := range str {
			if v == '.' { // Point
				if p > 0 || s > 0 || i+1 == l {
					return false
				}
				p = i
			} else if v == 'e' || v == 'E' { // Scientific
				if i == 0 || s > 0 || i+1 == l {
					return false
				}
				s = i
			} else if v < '0' || v > '9' {
				return false
			}
		}
		return true
	}

	return false
}
